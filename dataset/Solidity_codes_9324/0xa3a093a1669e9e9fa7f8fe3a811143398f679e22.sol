
pragma solidity ^0.8.0;

interface IERC165 {

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}// MIT

pragma solidity ^0.8.0;


library ERC165Checker {

    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;

    function supportsERC165(address account) internal view returns (bool) {

        return
            _supportsERC165Interface(account, type(IERC165).interfaceId) &&
            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);
    }

    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {

        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);
    }

    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)
        internal
        view
        returns (bool[] memory)
    {

        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);

        if (supportsERC165(account)) {
            for (uint256 i = 0; i < interfaceIds.length; i++) {
                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);
            }
        }

        return interfaceIdsSupported;
    }

    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {

        if (!supportsERC165(account)) {
            return false;
        }

        for (uint256 i = 0; i < interfaceIds.length; i++) {
            if (!_supportsERC165Interface(account, interfaceIds[i])) {
                return false;
            }
        }

        return true;
    }

    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {

        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);
        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);
        if (result.length < 32) return false;
        return success && abi.decode(result, (bool));
    }
}// MIT

pragma solidity ^0.8.0;



interface ICreatorCore is IERC165 {


    event ExtensionRegistered(address indexed extension, address indexed sender);
    event ExtensionUnregistered(address indexed extension, address indexed sender);
    event ExtensionBlacklisted(address indexed extension, address indexed sender);
    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);
    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);
    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);
    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);
    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);

    function getExtensions() external view returns (address[] memory);


    function registerExtension(address extension, string calldata baseURI) external;


    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;


    function unregisterExtension(address extension) external;


    function blacklistExtension(address extension) external;


    function setBaseTokenURIExtension(string calldata uri) external;


    function setBaseTokenURIExtension(string calldata uri, bool identical) external;


    function setTokenURIPrefixExtension(string calldata prefix) external;


    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;


    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;


    function setBaseTokenURI(string calldata uri) external;


    function setTokenURIPrefix(string calldata prefix) external;


    function setTokenURI(uint256 tokenId, string calldata uri) external;


    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;


    function setMintPermissions(address extension, address permissions) external;


    function setApproveTransferExtension(bool enabled) external;


    function tokenExtension(uint256 tokenId) external view returns (address);


    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;


    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;


    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;


    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);

    
    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);

    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);

    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);

    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);


}// MIT

pragma solidity ^0.8.0;



interface IERC721CreatorCore is ICreatorCore {


    function mintBase(address to) external returns (uint256);


    function mintBase(address to, string calldata uri) external returns (uint256);


    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);


    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);


    function mintExtension(address to) external returns (uint256);


    function mintExtension(address to, string calldata uri) external returns (uint256);


    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);


    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);


    function burn(uint256 tokenId) external;


}// MIT

pragma solidity ^0.8.0;

library EnumerableSet {


    struct Set {
        bytes32[] _values;
        mapping(bytes32 => uint256) _indexes;
    }

    function _add(Set storage set, bytes32 value) private returns (bool) {

        if (!_contains(set, value)) {
            set._values.push(value);
            set._indexes[value] = set._values.length;
            return true;
        } else {
            return false;
        }
    }

    function _remove(Set storage set, bytes32 value) private returns (bool) {

        uint256 valueIndex = set._indexes[value];

        if (valueIndex != 0) {

            uint256 toDeleteIndex = valueIndex - 1;
            uint256 lastIndex = set._values.length - 1;

            if (lastIndex != toDeleteIndex) {
                bytes32 lastvalue = set._values[lastIndex];

                set._values[toDeleteIndex] = lastvalue;
                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex
            }

            set._values.pop();

            delete set._indexes[value];

            return true;
        } else {
            return false;
        }
    }

    function _contains(Set storage set, bytes32 value) private view returns (bool) {

        return set._indexes[value] != 0;
    }

    function _length(Set storage set) private view returns (uint256) {

        return set._values.length;
    }

    function _at(Set storage set, uint256 index) private view returns (bytes32) {

        return set._values[index];
    }

    function _values(Set storage set) private view returns (bytes32[] memory) {

        return set._values;
    }


    struct Bytes32Set {
        Set _inner;
    }

    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {

        return _add(set._inner, value);
    }

    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {

        return _remove(set._inner, value);
    }

    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {

        return _contains(set._inner, value);
    }

    function length(Bytes32Set storage set) internal view returns (uint256) {

        return _length(set._inner);
    }

    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {

        return _at(set._inner, index);
    }

    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {

        return _values(set._inner);
    }


    struct AddressSet {
        Set _inner;
    }

    function add(AddressSet storage set, address value) internal returns (bool) {

        return _add(set._inner, bytes32(uint256(uint160(value))));
    }

    function remove(AddressSet storage set, address value) internal returns (bool) {

        return _remove(set._inner, bytes32(uint256(uint160(value))));
    }

    function contains(AddressSet storage set, address value) internal view returns (bool) {

        return _contains(set._inner, bytes32(uint256(uint160(value))));
    }

    function length(AddressSet storage set) internal view returns (uint256) {

        return _length(set._inner);
    }

    function at(AddressSet storage set, uint256 index) internal view returns (address) {

        return address(uint160(uint256(_at(set._inner, index))));
    }

    function values(AddressSet storage set) internal view returns (address[] memory) {

        bytes32[] memory store = _values(set._inner);
        address[] memory result;

        assembly {
            result := store
        }

        return result;
    }


    struct UintSet {
        Set _inner;
    }

    function add(UintSet storage set, uint256 value) internal returns (bool) {

        return _add(set._inner, bytes32(value));
    }

    function remove(UintSet storage set, uint256 value) internal returns (bool) {

        return _remove(set._inner, bytes32(value));
    }

    function contains(UintSet storage set, uint256 value) internal view returns (bool) {

        return _contains(set._inner, bytes32(value));
    }

    function length(UintSet storage set) internal view returns (uint256) {

        return _length(set._inner);
    }

    function at(UintSet storage set, uint256 index) internal view returns (uint256) {

        return uint256(_at(set._inner, index));
    }

    function values(UintSet storage set) internal view returns (uint256[] memory) {

        bytes32[] memory store = _values(set._inner);
        uint256[] memory result;

        assembly {
            result := store
        }

        return result;
    }
}// MIT

pragma solidity ^0.8.0;


abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}// MIT

pragma solidity ^0.8.0;

abstract contract Initializable {
    bool private _initialized;

    bool private _initializing;

    modifier initializer() {
        require(_initializing || !_initialized, "Initializable: contract is already initialized");

        bool isTopLevelCall = !_initializing;
        if (isTopLevelCall) {
            _initializing = true;
            _initialized = true;
        }

        _;

        if (isTopLevelCall) {
            _initializing = false;
        }
    }
}// MIT

pragma solidity ^0.8.0;

abstract contract ContextUpgradeable is Initializable {
    function __Context_init() internal initializer {
        __Context_init_unchained();
    }

    function __Context_init_unchained() internal initializer {
    }
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
    uint256[50] private __gap;
}// MIT

pragma solidity ^0.8.0;


abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function __Ownable_init() internal initializer {
        __Context_init_unchained();
        __Ownable_init_unchained();
    }

    function __Ownable_init_unchained() internal initializer {
        _setOwner(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _setOwner(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _setOwner(newOwner);
    }

    function _setOwner(address newOwner) private {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
    uint256[49] private __gap;
}// MIT

pragma solidity ^0.8.0;



interface IAdminControl is IERC165 {


    event AdminApproved(address indexed account, address indexed sender);
    event AdminRevoked(address indexed account, address indexed sender);

    function getAdmins() external view returns (address[] memory);


    function approveAdmin(address admin) external;


    function revokeAdmin(address admin) external;


    function isAdmin(address admin) external view returns (bool);


}// MIT

pragma solidity ^0.8.0;



abstract contract AdminControlUpgradeable is OwnableUpgradeable, IAdminControl, ERC165 {
    using EnumerableSet for EnumerableSet.AddressSet;

    EnumerableSet.AddressSet private _admins;

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IAdminControl).interfaceId
            || super.supportsInterface(interfaceId);
    }

    modifier adminRequired() {
        require(owner() == msg.sender || _admins.contains(msg.sender), "AdminControl: Must be owner or admin");
        _;
    }   

    function getAdmins() external view override returns (address[] memory admins) {
        admins = new address[](_admins.length());
        for (uint i = 0; i < _admins.length(); i++) {
            admins[i] = _admins.at(i);
        }
        return admins;
    }

    function approveAdmin(address admin) external override onlyOwner {
        if (!_admins.contains(admin)) {
            emit AdminApproved(admin, msg.sender);
            _admins.add(admin);
        }
    }

    function revokeAdmin(address admin) external override onlyOwner {
        if (_admins.contains(admin)) {
            emit AdminRevoked(admin, msg.sender);
            _admins.remove(admin);
        }
    }

    function isAdmin(address admin) public override view returns (bool) {
        return (owner() == admin || _admins.contains(admin));
    }

}// MIT

pragma solidity ^0.8.0;



interface IERC721CreatorExtensionApproveTransfer is IERC165 {


    function setApproveTransfer(address creator, bool enabled) external;


    function approveTransfer(address from, address to, uint256 tokenId) external returns (bool);

}// MIT

pragma solidity ^0.8.0;



abstract contract CreatorExtension is ERC165 {

    bytes4 constant internal LEGACY_EXTENSION_INTERFACE = 0x7005caad;

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165) returns (bool) {
        return interfaceId == LEGACY_EXTENSION_INTERFACE
            || super.supportsInterface(interfaceId);
    }
    
}// MIT

pragma solidity ^0.8.0;

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    function toString(uint256 value) internal pure returns (string memory) {


        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}// MIT

pragma solidity ^0.8.0;


interface ICollectionBase {


    event CollectionActivated(uint256 startTime, uint256 endTime, uint256 presaleInterval, uint256 claimStartTime, uint256 claimEndTime);
    event CollectionDeactivated();

    function nonceUsed(string memory nonce) external view returns(bool);

}// MIT

pragma solidity ^0.8.0;




interface IERC721Collection is ICollectionBase, IERC165 {


    event Unveil(uint256 collectibleId, address tokenAddress, uint256 tokenId);

    struct CollectionState {
        uint16 transactionLimit;
        uint16 purchaseMax;
        uint16 purchaseRemaining;
        uint256 purchasePrice;
        uint16 purchaseLimit;
        uint256 presalePurchasePrice;
        uint16 presalePurchaseLimit;
        uint16 purchaseCount;
        bool active;
        uint256 startTime;
        uint256 endTime;
        uint256 presaleInterval;
        uint256 claimStartTime;
        uint256 claimEndTime;
        bool useDynamicPresalePurchaseLimit;
    }

    function premint(uint16 amount) external;


    function premint(address[] calldata addresses) external;


    function setTokenURIPrefix(string calldata prefix) external;


    function withdraw(address payable recipient, uint256 amount) external;


    function setTransferLocked(bool locked) external;


    function activate(uint256 startTime_, uint256 duration, uint256 presaleInterval_, uint256 claimStartTime_, uint256 claimEndTime_) external;


    function deactivate() external;


    function claim(uint16 amount, bytes32 message, bytes calldata signature, string calldata nonce) external;

    
    function purchase(uint16 amount, bytes32 message, bytes calldata signature, string calldata nonce) external payable;


    function state() external view returns(CollectionState memory);


    function purchaseRemaining() external view returns(uint16);


}// MIT

pragma solidity ^0.8.0;

library ECDSA {

    enum RecoverError {
        NoError,
        InvalidSignature,
        InvalidSignatureLength,
        InvalidSignatureS,
        InvalidSignatureV
    }

    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {
            return; // no error: do nothing
        } else if (error == RecoverError.InvalidSignature) {
            revert("ECDSA: invalid signature");
        } else if (error == RecoverError.InvalidSignatureLength) {
            revert("ECDSA: invalid signature length");
        } else if (error == RecoverError.InvalidSignatureS) {
            revert("ECDSA: invalid signature 's' value");
        } else if (error == RecoverError.InvalidSignatureV) {
            revert("ECDSA: invalid signature 'v' value");
        }
    }

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        if (signature.length == 65) {
            bytes32 r;
            bytes32 s;
            uint8 v;
            assembly {
                r := mload(add(signature, 0x20))
                s := mload(add(signature, 0x40))
                v := byte(0, mload(add(signature, 0x60)))
            }
            return tryRecover(hash, v, r, s);
        } else if (signature.length == 64) {
            bytes32 r;
            bytes32 vs;
            assembly {
                r := mload(add(signature, 0x20))
                vs := mload(add(signature, 0x40))
            }
            return tryRecover(hash, r, vs);
        } else {
            return (address(0), RecoverError.InvalidSignatureLength);
        }
    }

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);
        _throwError(error);
        return recovered;
    }

    function tryRecover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address, RecoverError) {

        bytes32 s;
        uint8 v;
        assembly {
            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
            v := add(shr(255, vs), 27)
        }
        return tryRecover(hash, v, r, s);
    }

    function recover(
        bytes32 hash,
        bytes32 r,
        bytes32 vs
    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);
        _throwError(error);
        return recovered;
    }

    function tryRecover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address, RecoverError) {

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
            return (address(0), RecoverError.InvalidSignatureS);
        }
        if (v != 27 && v != 28) {
            return (address(0), RecoverError.InvalidSignatureV);
        }

        address signer = ecrecover(hash, v, r, s);
        if (signer == address(0)) {
            return (address(0), RecoverError.InvalidSignature);
        }

        return (signer, RecoverError.NoError);
    }

    function recover(
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
        _throwError(error);
        return recovered;
    }

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }
}// MIT

pragma solidity ^0.8.0;




abstract contract CollectionBase is ICollectionBase {
    
    using ECDSA for bytes32;
    using Strings for uint256;

    address internal _signingAddress;

    mapping(bytes32 => bool) private _usedNonces;

    bool public active;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public presaleInterval;

    uint256 public claimStartTime;
    uint256 public claimEndTime;

    function _withdraw(address payable recipient, uint256 amount) internal {
        (bool success,) = recipient.call{value:amount}("");
        require(success);
    }

    function _activate(uint256 startTime_, uint256 duration, uint256 presaleInterval_, uint256 claimStartTime_, uint256 claimEndTime_) internal virtual {
        require(!active, "Already active");
        require(startTime_ > block.timestamp, "Cannot activate in the past");
        require(presaleInterval_ < duration, "Presale Interval cannot be longer than the sale");
        require(claimStartTime_ <= claimEndTime_ && claimEndTime_ <= startTime_, "Invalid claim times");
        startTime = startTime_;
        endTime = startTime + duration;
        presaleInterval = presaleInterval_;
        claimStartTime = claimStartTime_;
        claimEndTime = claimEndTime_;
        active = true;

        emit CollectionActivated(startTime, endTime, presaleInterval, claimStartTime, claimEndTime);
    }

    function _deactivate() internal virtual {
        startTime = 0;
        endTime = 0;
        active = false;
        claimStartTime = 0;
        claimEndTime = 0;

        emit CollectionDeactivated();
    }

    function _getNonceBytes32(string memory nonce) internal pure returns(bytes32 nonceBytes32) {
        bytes memory nonceBytes = bytes(nonce);
        require(nonceBytes.length <= 32, "Invalid nonce");
        assembly {
            nonceBytes32 := mload(add(nonce, 32))
        }
    }

    function _validateClaimRequest(bytes32 message, bytes calldata signature, string calldata nonce, uint16 amount) internal virtual {
        _validatePurchaseRequestWithAmount(message, signature, nonce, amount);
    }

    function _validateClaimRestrictions() internal virtual {
        require(active, "Inactive");
        require(block.timestamp >= claimStartTime && block.timestamp <= claimEndTime, "Outside claim period.");
    }

    function _validatePurchaseRequest(bytes32 message, bytes calldata signature, string calldata nonce) internal virtual { 
        bytes32 nonceBytes32 = _getNonceBytes32(nonce);
        require(!_usedNonces[nonceBytes32], "Cannot replay transaction");
        bytes32 expectedMessage = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", (20+bytes(nonce).length).toString(), msg.sender, nonce));
        require(message == expectedMessage, "Malformed message");
        address signer = message.recover(signature);
        require(signer == _signingAddress, "Invalid signature");

        _usedNonces[nonceBytes32] = true;
    }

    function _validatePurchaseRequestWithAmount(bytes32 message, bytes calldata signature, string calldata nonce, uint16 amount) internal virtual {
        bytes32 nonceBytes32 = _getNonceBytes32(nonce);
        require(!_usedNonces[nonceBytes32], "Cannot replay transaction");
        bytes32 expectedMessage = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", (20+bytes(nonce).length+bytes(uint256(amount).toString()).length).toString(), msg.sender, nonce, uint256(amount).toString()));
        require(message == expectedMessage, "Malformed message");
        address signer = message.recover(signature);
        require(signer == _signingAddress, "Invalid signature");

        _usedNonces[nonceBytes32] = true;
    }

    function _validatePurchaseRestrictions() internal virtual {
        require(active, "Inactive");
        require(block.timestamp >= startTime, "Purchasing not active");
    }

    function nonceUsed(string memory nonce) external view override returns(bool) {
        bytes32 nonceBytes32 = _getNonceBytes32(nonce);
        return _usedNonces[nonceBytes32];
    }

    function _isPresale() internal view returns (bool) {
        return block.timestamp > startTime && block.timestamp - startTime < presaleInterval;
    }
}// MIT

pragma solidity ^0.8.0;




abstract contract ERC721CreatorCollectionBase is CollectionBase, CreatorExtension, IERC721Collection {
    
    using Strings for uint256;

    address internal _creator;
    uint16 public transactionLimit;
    uint16 public purchaseMax;
    uint256 public purchasePrice;
    uint16 public purchaseLimit;
    uint256 public presalePurchasePrice;
    uint16 public presalePurchaseLimit;
    bool public useDynamicPresalePurchaseLimit;

    uint16 public purchaseCount;
    mapping(address => uint16) internal _addressMintCount;

    bool public transferLocked;

    function _initialize(address creator, uint16 purchaseMax_, uint256 purchasePrice_, uint16 purchaseLimit_, uint16 transactionLimit_, uint256 presalePurchasePrice_, uint16 presalePurchaseLimit_, address signingAddress, bool useDynamicPresalePurchaseLimit_) internal {
        require(_creator == address(0) && _signingAddress == address(0), "Already initialized");
        _creator = creator;
        purchaseMax = purchaseMax_;
        purchasePrice = purchasePrice_;
        purchaseLimit = purchaseLimit_;
        transactionLimit = transactionLimit_;
        presalePurchasePrice = presalePurchasePrice_;
        presalePurchaseLimit = presalePurchaseLimit_;
        _signingAddress = signingAddress;
        useDynamicPresalePurchaseLimit = useDynamicPresalePurchaseLimit_;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(CreatorExtension, IERC165) returns (bool) {
      return interfaceId == type(IERC721Collection).interfaceId || CreatorExtension.supportsInterface(interfaceId);
    }

    function _premint(uint16 amount, address owner) internal virtual {
        require(!active, "Already active");
        _mint(owner, amount);
    }

    function _premint(address[] calldata addresses) internal virtual {
        require(!active, "Already active");
        for (uint i = 0; i < addresses.length; i++) {
            _mint(addresses[i], 1);
        }
    }

    function _mint(address to, uint16 amount) internal virtual {
        if (amount == 1) {
            purchaseCount++;
        
            uint256 tokenId = IERC721CreatorCore(_creator).mintExtension(to);
            
            emit Unveil(purchaseCount, _creator, tokenId);
        } else {
            uint256 tokenStart = purchaseCount+1;
            purchaseCount += amount;
        
            uint256[] memory tokenIds = IERC721CreatorCore(_creator).mintExtensionBatch(to, amount);

            for (uint i = 0; i < tokenIds.length; i++) {
                emit Unveil(tokenStart+i, _creator, tokenIds[i]);
            }
        }
    }

    function _setTokenURIPrefix(string calldata prefix) internal virtual {
        IERC721CreatorCore(_creator).setBaseTokenURIExtension(prefix);
    }
    
    function _validatePrice(uint16 amount) internal virtual {
      require(msg.value == amount*purchasePrice, "Invalid purchase amount sent");
    }

    function _validatePresalePrice(uint16 amount) internal virtual {
      require(msg.value == amount*presalePurchasePrice, "Invalid purchase amount sent");
    }

    function _validateTokenTransferability(address from) internal view returns(bool) {
        return from == address(0) || !transferLocked;
    }

    function _setTransferLocked(bool locked) internal {
        transferLocked = locked;
    }

    function claim(uint16 amount, bytes32 message, bytes calldata signature, string calldata nonce) external virtual override {
        _validateClaimRestrictions();
        _validateClaimRequest(message, signature, nonce, amount);
        _mint(msg.sender, amount);

        _addressMintCount[msg.sender] += amount;
    }
    
    function purchase(uint16 amount, bytes32 message, bytes calldata signature, string calldata nonce) external payable virtual override {
        _validatePurchaseRestrictions();

        bool isPresale = _isPresale();

        require(amount <= purchaseRemaining() && ((isPresale && useDynamicPresalePurchaseLimit) || transactionLimit == 0 || amount <= transactionLimit), "Too many requested");

        if (isPresale) {
            require(useDynamicPresalePurchaseLimit || ((presalePurchaseLimit == 0 || amount <= (presalePurchaseLimit-_addressMintCount[msg.sender])) && (purchaseLimit == 0 || amount <= (purchaseLimit-_addressMintCount[msg.sender]))), "Too many requested");
            _validatePresalePrice(amount);
            _addressMintCount[msg.sender] += amount;
        } else {
            require(purchaseLimit == 0 || amount <= (purchaseLimit-_addressMintCount[msg.sender]), "Too many requested");
            _validatePrice(amount);
            if (purchaseLimit != 0) {
                _addressMintCount[msg.sender] += amount;
            }
        }

        if (isPresale && useDynamicPresalePurchaseLimit) {
            _validatePurchaseRequestWithAmount(message, signature, nonce, amount);
        } else {
            _validatePurchaseRequest(message, signature, nonce);
        }

        _mint(msg.sender, amount);
    }

    function state() external override view returns(CollectionState memory) {
        return CollectionState(transactionLimit, purchaseMax, purchaseRemaining(), purchasePrice, purchaseLimit, presalePurchasePrice, presalePurchaseLimit, _addressMintCount[msg.sender], active, startTime, endTime, presaleInterval, claimStartTime, claimEndTime, useDynamicPresalePurchaseLimit);
    }

    function purchaseRemaining() public view virtual override returns(uint16) {
        return purchaseMax-purchaseCount;
    }

}// MIT

pragma solidity ^0.8.0;





contract ERC721CreatorCollectionImplementation is ERC721CreatorCollectionBase, IERC721CreatorExtensionApproveTransfer, AdminControlUpgradeable {


    function initialize(address creator, uint16 purchaseMax_, uint256 purchasePrice_, uint16 purchaseLimit_, uint16 transactionLimit_, uint256 presalePurchasePrice_, uint16 presalePurchaseLimit_, address signingAddress, bool useDynamicPresalePurchaseLimit_) public initializer {

        __Ownable_init();
        _initialize(creator, purchaseMax_, purchasePrice_, purchaseLimit_, transactionLimit_, presalePurchasePrice_, presalePurchaseLimit_, signingAddress, useDynamicPresalePurchaseLimit_);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721CreatorCollectionBase, IERC165, AdminControlUpgradeable) returns (bool) {

      return ERC721CreatorCollectionBase.supportsInterface(interfaceId)
        || AdminControlUpgradeable.supportsInterface(interfaceId)
        || interfaceId == type(IERC721CreatorExtensionApproveTransfer).interfaceId;
    }

    function withdraw(address payable recipient, uint256 amount) external override adminRequired {

        _withdraw(recipient, amount);
    }

    function setTransferLocked(bool locked) external override adminRequired {

        _setTransferLocked(locked);
    }

    function premint(uint16 amount) external override adminRequired {

        _premint(amount, owner());
    }

    function premint(address[] calldata addresses) external override adminRequired {

        _premint(addresses);
    }

    function activate(uint256 startTime_, uint256 duration, uint256 presaleInterval_, uint256 claimStartTime_, uint256 claimEndTime_) external override adminRequired {

        _activate(startTime_, duration, presaleInterval_, claimStartTime_, claimEndTime_);
    }

    function deactivate() external override adminRequired {

        _deactivate();
    }

    function setApproveTransfer(address creator, bool enabled) external override adminRequired {

        require(ERC165Checker.supportsInterface(creator, type(IERC721CreatorCore).interfaceId), "creator must implement IERC721CreatorCore");
        IERC721CreatorCore(creator).setApproveTransferExtension(enabled);
    }

    function approveTransfer(address from, address, uint256) external override returns (bool) {

        return _validateTokenTransferability(from);
    }

    function setTokenURIPrefix(string calldata prefix) external override adminRequired {

        _setTokenURIPrefix(prefix);
    }
}