
pragma solidity 0.5.11;

library SafeMath {

	function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
}

contract EURSToken {

    function transferFrom(address, address, uint256) public returns(bool);

    function transfer(address, uint256) public returns(bool);

}

contract BGBPToken {

    function transferFrom(address, address, uint256) public returns(bool);

    function transfer(address, uint256) public returns(bool);

}

contract USDTToken {

    function transferFrom(address, address, uint256) public returns(bool);

    function transfer(address, uint256) public returns(bool);

}

contract Syndicate {


	using SafeMath for uint;   //decrlare safe math library usage

	address public eursAddress = 0xdB25f211AB05b1c97D595516F45794528a807ad8;   //EURS stablecoin for EUR currency
	address public bgbpAddress = 0xC9a2C4868F0f96fAaa739b59934Dc9cB304112ec;   //BGBP stablecoin for GBP currency
	address public usdtAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;   //USDT stablecoin for USD currency
	uint256 public decimalCorrection;   //additional decimals (beyond cents/pennies) used in stablecoin, options = 1 (EURS), 1000000 (BGBP), 10000 (USDT)

    address public admin;   //admin's address
    uint256 public adminShare = 40;   //admin's share percent from profit generated by syndicate
    uint256 public adminProfit = 0;   //total net profit which belongs to admin
    
    address public angel;   //angel's (syndicate owner's) address
    uint256 public angelInvestment = 0;   //total amount of money angel has invested
    uint256 public angelProfit = 0;   //total net profit which belongs to angel

    uint256 public syndicateBalance = 0;   //current value of syndicate's balance
    int256 public syndicateProfit = 0;   //syndicate's current profit
    uint256 public distributionWaitTime;   //time (30 days) which needs to pass before monthly earnings are distributed among angel and admin
    uint256 public closureWaitTime;   //time (48h) which angel needs to wait before he/she can close syndicate after closure announcement
    
    struct Agreement {
        uint256 lsBalance;   //user's current, contract enforced LoopSyndicate balance
        uint256 lsInplay;   //user's current, contract enforced LoopSyndicate inplay balance
        uint256 bookieBalance;   //user's bookmakers current, contract enforced total balance
        uint256 bookieInplay;   //user's bookmakers current, contract enforced total inplay balance
        uint256 userBankroll;   //user's current, contract enforced total capital
        uint256 userProfit;   //total guaranteed profit user generated from placing bets and enforced by contract
    }
    mapping(address => Agreement) public userAgreements;
    
    struct Betting {
        uint256 lsBalance;   //user's LoopSyndicate new balance after settling latest bets placed by user (not enforced by contract yet)
        uint256 lsInplay;   //user's LoopSyndicate new inplay balance after settling latest bets placed by user (not enforced by contract yet)
        uint256 bookieBalance;   //user's bookmakers new total balance after settling latest bets placed by user (not enforced by contract yet)
        uint256 bookieInplay;   //user's bookmakers new total inplay balance after settling latest bets placed by user (not enforced by contract yet)
        uint256 userBankroll;   //user's new total capital after settling latest bets placed by user (not enforced by contract yet)
        uint256 userProfit;   //user's new guaranteed profit after settling latest bets placed by user (not enforced by contract yet)
        uint256 pubTime;   //publishing time of latest betting data
    }
    mapping(address => Betting) public bettingResults;

    
    bool public syndicateActive = true;   //angel's consent to "buy" users' value bets and in exchange provide guaranteed profit to them
    mapping(address => bool) public brokenAgreements;   //list of users who broke contract agreement from their side
    
    constructor(address _angel, uint256 _currency) public {
        admin = msg.sender;
        angel = _angel;
        if (_currency == 1) {
            decimalCorrection = 1;
        }
        else if (_currency == 2) {
            decimalCorrection = 1000000;
        }
        else if (_currency == 3) {
            decimalCorrection = 10000;
        }
    }

    modifier onlyAdmin() {

        require(msg.sender == admin, "only admin allowed to call this function");
        _;
    }

    event AgreementBreak (
        address _from
    );

    event ClosureAnnouncement (
        address _from
    );

    function eursTransferFrom(address _from, address _to, uint256 _coins) internal {

    	EURSToken stablecoin = EURSToken(eursAddress);
    	require(stablecoin.transferFrom(_from, _to, _coins), "error at EURS stablecoin transferFrom function");
    }

    function bgbpTransferFrom(address _from, address _to, uint256 _coins) internal {

    	BGBPToken stablecoin = BGBPToken(bgbpAddress);
    	require(stablecoin.transferFrom(_from, _to, _coins), "error at BGBP stablecoin transferFrom function");
    }

    function usdtTransferFrom(address _from, address _to, uint256 _coins) internal {

    	USDTToken stablecoin = USDTToken(usdtAddress);
    	require(stablecoin.transferFrom(_from, _to, _coins), "error at USDT stablecoin transferFrom function");
    }

    function eursTransfer(address _to, uint256 _coins) internal {

    	EURSToken stablecoin = EURSToken(eursAddress);
    	require(stablecoin.transfer(_to, _coins), "error at EURS stablecoin transfer function");
    }

    function bgbpTransfer(address _to, uint256 _coins) internal {

    	BGBPToken stablecoin = BGBPToken(bgbpAddress);
    	require(stablecoin.transfer(_to, _coins), "error at BGBP stablecoin transfer function");
    }

    function usdtTransfer(address _to, uint256 _coins) internal {

    	USDTToken stablecoin = USDTToken(usdtAddress);
    	require(stablecoin.transfer(_to, _coins), "error at USDT stablecoin transfer function");
    }
    
    function angelDeposit(address _from, uint256 _value) public {

        require(_value >= 10000, "deposit value less than minimum (10000 cents/pennies)");
        require(_from == angel, "from address does not match angel address");
        uint256 _coins = decimalCorrection.mul(_value);
        address _to = address(this);
        if (decimalCorrection == 1) {
        	eursTransferFrom(_from, _to, _coins);
        }
        else if (decimalCorrection == 1000000) {
        	bgbpTransferFrom(_from, _to, _coins);
        }
        else if (decimalCorrection == 10000) {
        	usdtTransferFrom(_from, _to, _coins);
        }
        syndicateBalance += _value;
        angelInvestment += _value;
    }
    
    function userDeposit(address _from, uint256 _value) public {

        require(syndicateActive, "angel has closed this syndicate");
        require(_value >= 100, "deposit value must be minimum 100 cents/pennies");
        uint256 _coins = decimalCorrection.mul(_value);
        address _to = address(this);
        if (decimalCorrection == 1) {
        	eursTransferFrom(_from, _to, _coins);
        }
        else if (decimalCorrection == 1000000) {
        	bgbpTransferFrom(_from, _to, _coins);
        }
        else if (decimalCorrection == 10000) {
        	usdtTransferFrom(_from, _to, _coins);
        }
        Agreement memory _agreement = userAgreements[_from];
        _agreement.lsBalance = _agreement.lsBalance + _value;
        userAgreements[_from] = _agreement;
        Betting memory _result = bettingResults[_from];
        _result.lsBalance = _result.lsBalance + _value;
        bettingResults[_from] = _result;
    }
    
    function displayResults(address _user, uint256 _lsBalance, uint256 _lsInplay, uint256 _bookieBalance, uint256 _bookieInplay, uint256 _userBankroll, uint256 _userProfit) public onlyAdmin {

        require(syndicateActive, "angel has closed this syndicate");
        require(!(brokenAgreements[_user]), "user has broken agreement");
        Agreement memory _agreement = userAgreements[_user];
        require(_agreement.lsBalance > 0 || _agreement.lsInplay > 0, "user does not have balance");
        Betting memory _result = bettingResults[_user];
        require(_result.pubTime == 0, "previous betting results were not applied");
        _result.lsBalance = _lsBalance;
        _result.lsInplay = _lsInplay;
        _result.bookieBalance = _bookieBalance;
        _result.bookieInplay = _bookieInplay;
        _result.userBankroll = _userBankroll;
        _result.userProfit = _userProfit;
        _result.pubTime = block.timestamp;
        bettingResults[_user] = _result;
    }

    function disableSyndicate() public {

        require(msg.sender == angel, "msg sender address does not match angel address");
        syndicateActive = false;
        if (syndicateBalance >= 10000) {
            syndicateBalance -= 10000;
            syndicateProfit -= 10000;
        }
        else {
            syndicateBalance = 0;
            syndicateProfit = 0;
        }
        if (syndicateProfit > 0) {
            syndicateBalance -= uint(syndicateProfit);
            syndicateProfit = 0;
        }
        emit AgreementBreak(msg.sender);
    }
    
    function breakAgreement() public {

        brokenAgreements[msg.sender] = true;
        emit AgreementBreak(msg.sender);
    }
    
    function setNewAgreement(address _user) public onlyAdmin returns(bool) {

        require(syndicateActive, "angel has closed this syndicate");
        require(!(brokenAgreements[_user]), "user has broken agreement");
        Agreement memory _agreement = userAgreements[_user];
        require(_agreement.lsBalance > 0 || _agreement.lsInplay > 0, "user does not have balance");
        Betting memory _result = bettingResults[_user];
        uint256 _waitLimit = _result.pubTime + 82800;   //there are 82,800 seconds in 23h
        if (_result.pubTime == 0 || block.timestamp < _waitLimit) {
            return false;
        }
       	uint256 _prevTotalLoopBalance = _agreement.lsBalance + _agreement.lsInplay;
       	uint256 _newTotalLoopBalance = _result.lsBalance + _result.lsInplay;
        int256 _profit = int(_prevTotalLoopBalance) - int(_newTotalLoopBalance);
        if (_profit < 0) {
            syndicateBalance -= uint(_profit);
        }
        else {
            syndicateBalance += uint(_profit);
        }
        syndicateProfit += _profit;
        _agreement.lsBalance = _result.lsBalance;
        _agreement.lsInplay = _result.lsInplay;
        _agreement.bookieBalance = _result.bookieBalance;
        _agreement.bookieInplay = _result.bookieInplay;
        _agreement.userBankroll = _result.userBankroll;
        _agreement.userProfit = _result.userProfit;
        userAgreements[_user] = _agreement;
        bettingResults[_user] = Betting(0, 0, 0, 0, 0, 0, 0);
        return true;
    }
    
    function userWithdraw(uint256 _value) public {

        Agreement memory _agreement = userAgreements[msg.sender];
        Betting memory _result = bettingResults[msg.sender];
        if (brokenAgreements[msg.sender]) {
            _value = _agreement.lsBalance + _agreement.lsInplay;
            _agreement.lsBalance = _agreement.lsBalance + _agreement.lsInplay;
            _agreement.lsInplay = 0;
        }
        else {
            require(_result.lsBalance >= _value, "user balance is less than withdrawal value");
	       	uint256 _prevTotalLoopBalance = _agreement.lsBalance + _agreement.lsInplay;
	       	uint256 _newTotalLoopBalance = _result.lsBalance + _result.lsInplay;
	        int256 _profit = int(_prevTotalLoopBalance) - int(_newTotalLoopBalance);
	        if (_profit < 0) {
	            syndicateBalance -= uint(_profit);
	        }
	        else {
	            syndicateBalance += uint(_profit);
	        }
	        syndicateProfit += _profit;
            _agreement.lsBalance = _result.lsBalance;
            _agreement.lsInplay = _result.lsInplay;
            _agreement.bookieBalance = _result.bookieBalance;
            _agreement.bookieInplay = _result.bookieInplay;
            _agreement.userBankroll = _result.userBankroll;
            _agreement.userProfit = _result.userProfit;
        }
        uint256 _coins = decimalCorrection.mul(_value);
        if (decimalCorrection == 1) {
        	eursTransfer(msg.sender, _coins);
        }
        else if (decimalCorrection == 1000000) {
        	bgbpTransfer(msg.sender, _coins);
        }
        else if (decimalCorrection == 10000) {
        	usdtTransfer(msg.sender, _coins);
        }
        _agreement.lsBalance = _agreement.lsBalance - _value;
        userAgreements[msg.sender] = _agreement;
        _result.lsBalance = _agreement.lsBalance;
        bettingResults[msg.sender] = _result;
    }
    
    function distributeEarnings() public returns(bool) {

        require(block.timestamp > distributionWaitTime, "month did not pass since last earnings distribution");
        if (syndicateProfit < 100) {
            return false;
        }
        uint256 _share = uint(syndicateProfit) * adminShare / 100;
        adminProfit += _share;
        syndicateBalance -= _share;
        syndicateProfit -= int(_share);
        angelProfit += uint(syndicateProfit);
        syndicateBalance -= uint(syndicateProfit);
        syndicateProfit = 0;
        distributionWaitTime = block.timestamp + 2592000;   //there are 2,592,000 seconds in 30 days
        return true;
    }
    
    function angelWithdraw() public {

        require(msg.sender == angel, "msg sender address does not match angel address");
        require(angelProfit > 0, "angel does not have profit to withdraw");
        uint256 _coins = decimalCorrection * angelProfit;
        if (decimalCorrection == 1) {
        	eursTransfer(msg.sender, _coins);
        }
        else if (decimalCorrection == 1000000) {
        	bgbpTransfer(msg.sender, _coins);
        }
        else if (decimalCorrection == 10000) {
        	usdtTransfer(msg.sender, _coins);
        }
        angelProfit = 0;
    }
    
    function angelReinvest() public {

        require(msg.sender == angel, "msg sender address does not match angel address");
        require(angelProfit > 0, "angel does not have profit to reinvest");
        syndicateBalance += angelProfit;
        angelProfit = 0;
    }
    
    function adminWithdraw(address _to) public onlyAdmin {

        require(adminProfit > 0, "admin does not have profit share");
        uint256 _coins = decimalCorrection * adminProfit;
        if (decimalCorrection == 1) {
        	eursTransfer(_to, _coins);
        }
        else if (decimalCorrection == 1000000) {
        	bgbpTransfer(_to, _coins);
        }
        else if (decimalCorrection == 10000) {
        	usdtTransfer(_to, _coins);
        }
        adminProfit = 0;
    }

    function announceClosure() public {

        require(msg.sender == angel, "msg sender address does not match angel address");
        closureWaitTime = block.timestamp + 172800;   //there are 172,800 seconds in 48 hours
        emit ClosureAnnouncement(msg.sender);
    }

    function closeSyndicate() public {

        require(block.timestamp > closureWaitTime && closureWaitTime != 0, "2 days did not pass since closure announcement");
        if (syndicateProfit >= 100) {
            uint256 _share = uint(syndicateProfit) * adminShare / 100;
            adminProfit += _share;
            syndicateBalance -= _share;
            syndicateProfit = 0;
        }
        uint256 _coins = decimalCorrection * syndicateBalance;
        if (decimalCorrection == 1) {
        	eursTransfer(angel, _coins);
        }
        else if (decimalCorrection == 1000000) {
        	bgbpTransfer(angel, _coins);
        }
        else if (decimalCorrection == 10000) {
        	usdtTransfer(angel, _coins);
        }
        syndicateBalance = 0;
        angelInvestment = 0;
        syndicateActive = false;
        closureWaitTime = 0;
    }
    
}