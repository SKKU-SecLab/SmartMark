
pragma solidity ^0.8.0;

library Counters {

    struct Counter {
        uint256 _value; // default: 0
    }

    function current(Counter storage counter) internal view returns (uint256) {

        return counter._value;
    }

    function increment(Counter storage counter) internal {

        unchecked {
            counter._value += 1;
        }
    }

    function decrement(Counter storage counter) internal {

        uint256 value = counter._value;
        require(value > 0, "Counter: decrement overflow");
        unchecked {
            counter._value = value - 1;
        }
    }

    function reset(Counter storage counter) internal {

        counter._value = 0;
    }
}// MIT

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}// MIT

pragma solidity ^0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _transferOwnership(_msgSender());
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}// AGPL-3.0-only
pragma solidity 0.8.9;

abstract contract ERC721U {

    event Transfer(address indexed from, address indexed to, uint256 indexed id);

    event Approval(address indexed owner, address indexed spender, uint256 indexed id);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);


    string public name;

    string public symbol;

    function tokenURI(uint256 id) public view virtual returns (string memory);


    mapping(address => uint256) public balanceOf;

    mapping(uint256 => address) public ownerOf;

    mapping(uint256 => address) public getApproved;

    mapping(address => mapping(address => bool)) public isApprovedForAll;


    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
    }


    function approve(address spender, uint256 id) public virtual {
        address owner = ownerOf[id];

        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");

        getApproved[id] = spender;

        emit Approval(owner, spender, id);
    }

    function setApprovalForAll(address operator, bool approved) public virtual {
        isApprovedForAll[msg.sender][operator] = approved;

        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function transferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        require(from == ownerOf[id], "WRONG_FROM");

        require(to != address(0), "INVALID_RECIPIENT");

        require(
            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],
            "NOT_AUTHORIZED"
        );

        unchecked {
            balanceOf[from]--;

            balanceOf[to]++;
        }

        ownerOf[id] = to;

        delete getApproved[id];

        emit Transfer(from, to, id);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id
    ) public virtual {
        transferFrom(from, to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "") ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        bytes calldata data
    ) public virtual {
        transferFrom(from, to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }


    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
    }


    function _mint(address to, uint256 id) internal virtual {
        require(to != address(0), "INVALID_RECIPIENT");

        require(ownerOf[id] == address(0), "ALREADY_MINTED");

        unchecked {
            balanceOf[to]++;
        }

        ownerOf[id] = to;

        emit Transfer(address(0), to, id);
    }

    function _burn(uint256 id) internal virtual {
        address owner = ownerOf[id];

        require(owner != address(0), "NOT_MINTED");

        unchecked {
            balanceOf[owner]--;
        }

        delete ownerOf[id];

        delete getApproved[id];

        emit Transfer(owner, address(0), id);
    }


    function _safeMint(address to, uint256 id) internal virtual {
        _mint(to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "") ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }

    function _safeMint(
        address to,
        uint256 id,
        bytes memory data
    ) internal virtual {
        _mint(to, id);

        require(
            to.code.length == 0 ||
                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==
                ERC721TokenReceiver.onERC721Received.selector,
            "UNSAFE_RECIPIENT"
        );
    }
}

abstract contract ERC721TokenReceiver {
    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external virtual returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}// MIT
pragma solidity 0.8.9;

enum IngredientType {
    Base,
    Sauce,
    Cheese,
    Meat,
    Topping
}

struct Ingredient {
    string name;
    IngredientType ingredientType;
    address artist;
    uint256 price;
    uint256 supply;
    uint256 initialSupply;
}

struct Pizza {
    uint16 base;
    uint16 sauce;
    uint16[3] cheeses;
    uint16[4] meats;
    uint16[4] toppings;
}

interface ILazlosIngredients {

    function getNumIngredients() external view returns (uint256);

    function getIngredient(uint256 tokenId) external view returns (Ingredient memory);

    function increaseIngredientSupply(uint256 tokenId, uint256 amount) external;

    function decreaseIngredientSupply(uint256 tokenId, uint256 amount) external;

    function mintIngredients(address addr, uint256[] memory tokenIds, uint256[] memory amounts) external;

    function burnIngredients(address addr, uint256[] memory tokenIds, uint256[] memory amounts) external;

    function balanceOfAddress(address addr, uint256 tokenId) external view returns (uint256);

}

interface ILazlosPizzas {

    function bake(address baker, Pizza memory pizza) external returns (uint256);

    function rebake(address baker, uint256 pizzaTokenId, Pizza memory pizza) external;

    function pizza(uint256 tokenId) external view returns (Pizza memory);

    function burn(uint256 tokenId) external;

}

interface ILazlosRendering {

    function ingredientTokenMetadata(uint256 id) external view returns (string memory); 

    function pizzaTokenMetadata(uint256 id) external view returns (string memory); 

}// MIT
pragma solidity 0.8.9;



contract LazlosPizzas is ERC721U, Ownable {

    using Counters for Counters.Counter;

    modifier onlyPizzaShop() {

        require(msg.sender == pizzaShopContractAddress, 'Only the pizza shop can call this method.');
        _;
    }

    address public pizzaShopContractAddress;
    address public renderingContractAddress;

    Counters.Counter public numPizzas;
    mapping(uint256 => Pizza) pizzas;

    constructor() ERC721U("Lazlo's Pizza", "LAZLO") {}

    function setPizzaShopContractAddress(address addr) public onlyOwner {

        pizzaShopContractAddress = addr;
    }

    function setRenderingContractAddress(address addr) public onlyOwner {

        renderingContractAddress = addr;
    }

    function tokenURI(uint256 id) public view override returns (string memory) {

        return ILazlosRendering(renderingContractAddress).pizzaTokenMetadata(id);
    }

    function bake(address baker, Pizza memory pizzaData) external onlyPizzaShop returns (uint256) {

        numPizzas.increment();
        uint256 tokenId = numPizzas.current();
        pizzas[tokenId] = pizzaData;

        _safeMint(baker, tokenId);

        return tokenId;
    }

    function rebake(address baker, uint256 pizzaTokenId, Pizza memory pizzaData) external onlyPizzaShop {

        require(baker == ownerOf[pizzaTokenId], "Baker doesn't own this pizza.");

        pizzas[pizzaTokenId] = pizzaData;
    }

    function pizza(uint256 tokenId) external view returns (Pizza memory) {

        return pizzas[tokenId];
    }

    function burn(uint256 tokenId) external onlyPizzaShop {

        _burn(tokenId);
    }
}