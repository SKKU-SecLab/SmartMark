

pragma solidity 0.6.12;



interface ICurveGauge {

    function deposit(uint256) external;

    function balanceOf(address) external view returns (uint256);

    function withdraw(uint256) external;

    function claim_rewards() external;

    function reward_tokens(uint256) external view returns(address);//v2

    function rewarded_token() external view returns(address);//v1

    function lp_token() external view returns(address);

}

interface ICurveVoteEscrow {

    function create_lock(uint256, uint256) external;

    function increase_amount(uint256) external;

    function increase_unlock_time(uint256) external;

    function withdraw() external;

    function smart_wallet_checker() external view returns (address);

}

interface IWalletChecker {

    function check(address) external view returns (bool);

}

interface IVoting{

    function vote(uint256, bool, bool) external; //voteId, support, executeIfDecided

    function getVote(uint256) external view returns(bool,bool,uint64,uint64,uint64,uint64,uint256,uint256,uint256,bytes memory); 

    function vote_for_gauge_weights(address,uint256) external;

}

interface IMinter{

    function mint(address) external;

}

interface IRegistry{

    function get_registry() external view returns(address);

    function get_address(uint256 _id) external view returns(address);

    function gauge_controller() external view returns(address);

    function get_lp_token(address) external view returns(address);

    function get_gauges(address) external view returns(address[10] memory,uint128[10] memory);

}

interface IStaker{

    function deposit(address, address) external;

    function withdraw(address) external;

    function withdraw(address, address, uint256) external;

    function withdrawAll(address, address) external;

    function createLock(uint256, uint256) external;

    function increaseAmount(uint256) external;

    function increaseTime(uint256) external;

    function release() external;

    function claimCrv(address) external returns (uint256);

    function claimRewards(address) external;

    function claimFees(address,address) external;

    function setStashAccess(address, bool) external;

    function vote(uint256,address,bool) external;

    function voteGaugeWeight(address,uint256) external;

    function balanceOfPool(address) external view returns (uint256);

    function operator() external view returns (address);

    function execute(address _to, uint256 _value, bytes calldata _data) external returns (bool, bytes memory);

}

interface IRewards{

    function stake(address, uint256) external;

    function stakeFor(address, uint256) external;

    function withdraw(address, uint256) external;

    function exit(address) external;

    function getReward(address) external;

    function queueNewRewards(uint256) external;

    function notifyRewardAmount(uint256) external;

    function addExtraReward(address) external;

    function stakingToken() external view returns (address);

    function rewardToken() external view returns(address);

    function earned(address account) external view returns (uint256);

}

interface IStash{

    function stashRewards() external returns (bool);

    function processStash() external returns (bool);

    function claimRewards() external returns (bool);

    function initialize(uint256 _pid, address _operator, address _staker, address _gauge, address _rewardFactory) external;

}

interface IFeeDistro{

    function claim() external;

    function token() external view returns(address);

}

interface ITokenMinter{

    function mint(address,uint256) external;

    function burn(address,uint256) external;

}

interface IDeposit{

    function isShutdown() external view returns(bool);

    function balanceOf(address _account) external view returns(uint256);

    function totalSupply() external view returns(uint256);

    function poolInfo(uint256) external view returns(address,address,address,address,address, bool);

    function rewardClaimed(uint256,address,uint256) external;

    function withdrawTo(uint256,uint256,address) external;

    function claimRewards(uint256,address) external returns(bool);

    function rewardArbitrator() external returns(address);

    function setGaugeRedirect(uint256 _pid) external returns(bool);

    function owner() external returns(address);

}

interface ICrvDeposit{

    function deposit(uint256, bool) external;

    function lockIncentive() external view returns(uint256);

}

interface IRewardFactory{

    function setAccess(address,bool) external;

    function CreateCrvRewards(uint256,address) external returns(address);

    function CreateTokenRewards(address,address,address) external returns(address);

    function activeRewardCount(address) external view returns(uint256);

    function addActiveReward(address,uint256) external returns(bool);

    function removeActiveReward(address,uint256) external returns(bool);

}

interface IStashFactory{

    function CreateStash(uint256,address,address,uint256) external returns(address);

}

interface ITokenFactory{

    function CreateDepositToken(address) external returns(address);

}

interface IPools{

    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external returns(bool);

    function shutdownPool(uint256 _pid) external returns(bool);

    function poolInfo(uint256) external view returns(address,address,address,address,address,bool);

    function poolLength() external view returns (uint256);

    function gaugeMap(address) external view returns(bool);

    function setPoolManager(address _poolM) external;

}

interface IVestedEscrow{

    function fund(address[] calldata _recipient, uint256[] calldata _amount) external returns(bool);

}

pragma solidity 0.6.12;


contract PoolManagerProxy{


    address public constant pools = address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);
    address public owner;
    address public operator;

    constructor() public {
        owner = address(0xa3C5A1e09150B75ff251c1a7815A07182c3de2FB);
        operator = msg.sender;
    }

    modifier onlyOwner() {

        require(owner == msg.sender, "!owner");
        _;
    }

    modifier onlyOperator() {

        require(operator == msg.sender, "!op");
        _;
    }

    function setOwner(address _owner) external onlyOwner{

        owner = _owner;
    }

    function setOperator(address _operator) external onlyOwner{

        operator = _operator;
    }


    function shutdownPool(uint256 _pid) external onlyOperator returns(bool){

        return IPools(pools).shutdownPool(_pid);
    }

    function addPool(address _lptoken, address _gauge, uint256 _stashVersion) external onlyOperator returns(bool){


        require(_gauge != address(0),"gauge is 0");
        require(_lptoken != address(0),"lp token is 0");

        bool gaugeExists = IPools(pools).gaugeMap(_gauge);
        require(!gaugeExists, "already registered gauge");

        gaugeExists = IPools(pools).gaugeMap(_lptoken);
        require(!gaugeExists, "already registered lptoken");

        return IPools(pools).addPool(_lptoken,_gauge,_stashVersion);
    }
}