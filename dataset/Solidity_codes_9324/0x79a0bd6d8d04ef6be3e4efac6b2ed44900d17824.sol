
pragma solidity 0.4.17;
library Pairing {

    struct G1Point {
        uint X;
        uint Y;
    }
    struct G2Point {
        uint[2] X;
        uint[2] Y;
    }
    function P1() pure internal returns (G1Point) {

        return G1Point(1, 2);
    }
    function P2() pure internal returns (G2Point) {

        return G2Point(
            [11559732032986387107991004021392285783925812861821192530917403151452391805634,
             10857046999023057135944570762232829481370756359578518086990519993285655852781],
            [4082367875863433681332203403145435568316851327593401208105741076214120093531,
             8495653923123431417604973247489272438418190587263600148770280649306958101930]
        );

    }
    function negate(G1Point p) pure internal returns (G1Point) {

        uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
        if (p.X == 0 && p.Y == 0)
            return G1Point(0, 0);
        return G1Point(p.X, q - (p.Y % q));
    }
    function addition(G1Point p1, G1Point p2) view internal returns (G1Point r) {

        uint[4] memory input;
        input[0] = p1.X;
        input[1] = p1.Y;
        input[2] = p2.X;
        input[3] = p2.Y;
        bool success;
        assembly {
            success := staticcall(sub(gas, 2000), 6, input, 0xc0, r, 0x60)
            switch success case 0 { invalid() }
        }
        require(success);
    }
    function scalar_mul(G1Point p, uint s) view internal returns (G1Point r) {

        uint[3] memory input;
        input[0] = p.X;
        input[1] = p.Y;
        input[2] = s;
        bool success;
        assembly {
            success := staticcall(sub(gas, 2000), 7, input, 0x80, r, 0x60)
            switch success case 0 { invalid() }
        }
        require (success);
    }
    function pairing(G1Point[] p1, G2Point[] p2) view internal returns (bool) {

        require(p1.length == p2.length);
        uint elements = p1.length;
        uint inputSize = elements * 6;
        uint[] memory input = new uint[](inputSize);
        for (uint i = 0; i < elements; i++)
        {
            input[i * 6 + 0] = p1[i].X;
            input[i * 6 + 1] = p1[i].Y;
            input[i * 6 + 2] = p2[i].X[0];
            input[i * 6 + 3] = p2[i].X[1];
            input[i * 6 + 4] = p2[i].Y[0];
            input[i * 6 + 5] = p2[i].Y[1];
        }
        uint[1] memory out;
        bool success;
        assembly {
            success := staticcall(sub(gas, 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)
            switch success case 0 { invalid() }
        }
        require(success);
        return out[0] != 0;
    }
    function pairingProd2(G1Point a1, G2Point a2, G1Point b1, G2Point b2) view internal returns (bool) {

        G1Point[] memory p1 = new G1Point[](2);
        G2Point[] memory p2 = new G2Point[](2);
        p1[0] = a1;
        p1[1] = b1;
        p2[0] = a2;
        p2[1] = b2;
        return pairing(p1, p2);
    }
    function pairingProd3(
            G1Point a1, G2Point a2,
            G1Point b1, G2Point b2,
            G1Point c1, G2Point c2
    ) view internal returns (bool) {

        G1Point[] memory p1 = new G1Point[](3);
        G2Point[] memory p2 = new G2Point[](3);
        p1[0] = a1;
        p1[1] = b1;
        p1[2] = c1;
        p2[0] = a2;
        p2[1] = b2;
        p2[2] = c2;
        return pairing(p1, p2);
    }
    function pairingProd4(
            G1Point a1, G2Point a2,
            G1Point b1, G2Point b2,
            G1Point c1, G2Point c2,
            G1Point d1, G2Point d2
    ) view internal returns (bool) {

        G1Point[] memory p1 = new G1Point[](4);
        G2Point[] memory p2 = new G2Point[](4);
        p1[0] = a1;
        p1[1] = b1;
        p1[2] = c1;
        p1[3] = d1;
        p2[0] = a2;
        p2[1] = b2;
        p2[2] = c2;
        p2[3] = d2;
        return pairing(p1, p2);
    }
}
contract Verifier {

    using Pairing for *;
    struct VerifyingKey {
        Pairing.G1Point alfa1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;
    }
    struct Proof {
        Pairing.G1Point A;
        Pairing.G2Point B;
        Pairing.G1Point C;
    }
    function verifyingKey() pure internal returns (VerifyingKey vk) {

        vk.alfa1 = Pairing.G1Point(13042714416704416103752233100858880973276004191055193830790388914968659762136,4202645424756949116663092611884341411678346306792605716520510006855446651903);
        vk.beta2 = Pairing.G2Point([11227169185166352652645369848289392221921632223909789492171761315942478786982,7628004330308641733630265729358617458368070012720355334087176960895420132638], [3292518835045132846789734025729109543304043511274141423793363359904233055493,14124075324837247595236734464156291626725258930543783205487521254991007966263]);
        vk.gamma2 = Pairing.G2Point([1370888600228250952233001804167561384028603344988569483060156038205014434752,1138844093930026517602457201882340159974842325510268155325700534256549967502], [9857122040149453087155630725058214973692946000202352666963774414406089680384,8327679409014069902367281054265991472284466645979105149782481406471227397606]);
        vk.delta2 = Pairing.G2Point([13188316339216551753541534836550617318166458760192768669750611936387554240868,16116072901785505080768204330283742611111597347068761754405972671049558702434], [10632443723761637337539040881693204127406519609478857645463068224391649153468,2813269835567372809955360743522198048316337822889930422296933127706476870945]);
        vk.IC = new Pairing.G1Point[](2);
        vk.IC[0] = Pairing.G1Point(19273405593073374149717360441261180629953772224330597548764276740875281039288,9214339914580717027232701509637711007530585947000985513609447054686473672327);
        vk.IC[1] = Pairing.G1Point(19064415239770804726186125241207551604913739712304197861850873186376299719603,14666338528768348158920009993233355233063279284930878550432755715112049329956);

    }
    function verify(uint[] input, Proof proof) view internal returns (uint) {

        VerifyingKey memory vk = verifyingKey();
        require(input.length + 1 == vk.IC.length);
        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);
        for (uint i = 0; i < input.length; i++)
            vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));
        vk_x = Pairing.addition(vk_x, vk.IC[0]);
        if (!Pairing.pairingProd4(
            Pairing.negate(proof.A), proof.B,
            vk.alfa1, vk.beta2,
            vk_x, vk.gamma2,
            proof.C, vk.delta2
        )) return 1;
        return 0;
    }
    function verifyProof(
            uint[2] a,
            uint[2][2] b,
            uint[2] c,
            uint[1] input
        ) view public returns (bool r) {

        Proof memory proof;
        proof.A = Pairing.G1Point(a[0], a[1]);
        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
        proof.C = Pairing.G1Point(c[0], c[1]);
        uint[] memory inputValues = new uint[](input.length);
        for(uint i = 0; i < input.length; i++){
            inputValues[i] = input[i];
        }
        if (verify(inputValues, proof) == 0) {
            return true;
        } else {
            return false;
        }
    }
}